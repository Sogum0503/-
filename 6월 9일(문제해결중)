1. 해당 쿼리의 문제는 무엇인가?

WITH sub_table AS (
  SELECT 
    t1.station_id AS station_id,
    t1.name AS name,
    2 * 6356 * asin(sqrt(pow(sin((radians(t1.lat) - radians(t2.lat)) / 2 ), 2) +
    cos(radians(t1.lat)) * cos(radians(t2.lat)) *
    pow(sin((radians(t1.lng) - radians(t2.lng)) / 2), 2))) AS distance
  FROM station t1
      INNER JOIN station t2 on t1.station_id = t2.station_id -- 여기 ! 
  WHERE t1.updated_at < t2.updated_at)
  
SELECT station_id
        ,name
FROM sub_table 
WHERE distance <= 0.3 
GROUP BY station_id,name
having count(*) >= 5


1.1 과정 

스터디원분이 해당 쿼리가 돌아가지 않는다며 도움을 요청하셨다.

이전까지는 t1.station_id != t2.station_id로 조건을 걸어서 self-join을 했는데
t1.station_id = t2.station_id로 하게되면 같은 한 지점이 되어서 결과값이 출력되지 못한다.

그런데 여기서 궁금증..!
t1.station_id != t2.station_id 하는것과 아예 조건을 걸지 않고 self-join해서 문제를 푸는 것과 무엇이 더 성능이 좋을까? 

1.3. 추가로 본 블로그  
https://self-interest.tistory.com/entry/ON-%EC%A1%B0%EA%B1%B4-%EC%97%86%EC%9D%B4-%EC%A1%B0%EC%9D%B8JOIN-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95


[solve_sql 문제풀이] 
1. 가구 판매의 비중이 높은 날 

SELECT order_date 
      , COUNT(DISTINCT CASE WHEN category = 'Furniture' THEN order_id END) AS 'furniture'
     -- , COUNT(DISTINCT order_id) AS "todays_order"
      , ROUND(COUNT(DISTINCT CASE WHEN category = 'Furniture' THEN order_id END)/COUNT(DISTINCT order_id) * 100,2) AS "furniture_pct"
FROM records 
GROUP BY order_date
HAVING COUNT(DISTINCT order_id) >= 10 
AND furniture_pct >= 40
AND furniture_pct >= 0.4

1.1. 회고 및 주저리 

2.

