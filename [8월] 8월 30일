[1875#_MEDIUM] Group Employees of the Same Salary

# 풀이 과정 
team_id를 구하기 위해서 salary값에 rank값을 부여하면 되겠구나 생각함.

dense_rank를 먼저 하고 필터링 조건을 걸어주면 rank값이 연속적으로 이어지지 않음.
그래서 공통인자인 salary를 기준으로 필터링(유니크한 값 제거)을 해서 temp 테이블을 생성함.
(salary가 아닌 employee_id를 기준으로 잡았을 때 집계함수 때문에 2명이 아닌 1명만 출력되는 문제가 발생됨) 

temp 테이블에 dense_rank 함수를 이용해서 team_id 부여. 

# 최종쿼리 
with temp as (
    select *
    from employees 
    where salary in (select salary
                        from employees
                         group by salary
                         having count(employee_id) > 1))

select *,
    dense_rank() over(order by salary) team_id 
from temp 
order by team_id, employee_id

----------------------------------------------------------------------
[1907#_MEDIUM] Count Salary Categories

# 문제 풀이 
조건문을 사용한 다음, group by로 집계를 하게 되면 count(*) = 0인 category는 집계되지 않는 문제가 발생했다.
아웃풋 형태를 보면 category 컬럼에는 "Low","Average","High"가 나열되어 있기 때문에 
Category 컬럼에 "Low","Average","High" 문자 데이터를 생성하는 작업을 진행하고 
각 카테고리에 해당되는 accounts를 count하여 accounts_count 컬럼을 만드는 것은 어떨까? ▼

SELECT "Low Salary" AS category,
        COUNT(case when income < 20000 then account_id end) as accounts_count
FROM Accounts 
UNION
SELECT "Average Salary" AS category,
        COUNT(CASE WHEN income BETWEEN 20000 AND 50000 THEN account_id END) as accounts_count
FROM Accounts 
UNION
SELECT "High Salary" AS category,
        COUNT(CASE WHEN income > 50000 THEN account_id END) as accounts_count
FROM Accounts
